// Простой демонстрационный файл: переменные в Rust.
// Комментарии подробно объясняют синтаксис и почему он нужен.

// const — объявление константы. Константы имеют имя в верхнем регистре по
// соглашению, обязателен явный указанный тип (здесь u32).
// Значение константы нельзя изменить во время работы программы.
const MAX_POINTS: u32 = 100_000;

fn main() {
    // println! — макрос для вывода в консоль.
    // "!" означает, что это макрос, не функция.
    // Первый аргумент в println! — строковый литерал с плейсхолдерами "{}".
    // Каждый плейсхолдер заменяется следующими аргументами в порядке их передачи.
    println!("=== Быстро про переменные в Rust ===");

    // let — создание связывания (binding). Связывание даёт имя значению.
    // По умолчанию связывание НЕИЗМЕНЯЕМОЕ: нельзя присвоить новое значение тому же
    // имени. 5 — литерал типа i32 (по умолчанию для целых в выражениях), можем
    // не указывать тип явно.
    let x = 5; // '=' — оператор присваивания/инициализации; ';' — завершает выражение/инструкцию.
    println!("1) let x = 5;  // x = {}", x);

    // Shadowing (затенение): повторный let с тем же именем создаёт новое
    // связывание. Это НЕ то же самое, что mut: это новое имя, которое
    // "перекрывает" старое в текущей области.
    let x = x + 1; // берём старое значение x, прибавляем 1, создаём новое связывание с тем же именем.
    println!("2) shadowing: let x = x + 1;  // x = {}", x);

    // mut — делает связывание изменяемым. Когда значение нужно присвоить позже —
    // используем mut. Если переменная объявлена как mut, можно делать
    // присвоения в том же связывании.
    let mut y = 10; // объявляем y и сразу инициализируем равным 10
    println!("3) let mut y = 10;  // y = {}", y);
    y = 20; // присваивание новому значению в том же связывании (т.к. y — mut)
    println!("   после присвоения: y = {}", y);

    // Явная аннотация типа: двойной двоеточие ':' после имени переменной —
    // указывает тип. Полезно, когда нужно явно задавать точный тип (например,
    // f64 вместо f32).
    let z: f64 = 3.14; // ':' разделяет имя и тип, '=' присваивает значение.
    println!("4) let z: f64 = 3.14;  // z = {}", z);

    // String — динамически выделяемая строка (heap). String::from создаёт String из
    // &str. String НЕ реализует трейт Copy, поэтому при присваивании владение
    // перемещается.
    let mut s = String::from("hello"); // String::from — функция, создаёт объект String.
    // push_str — метод структуры String, добавляет текст в конец.
    s.push_str(", world!"); // '.' — вызов метода; push_str изменяет содержимое.
    println!("5) String: s = {}", s);

    // Вывод константы:
    println!("6) Константа MAX_POINTS = {}", MAX_POINTS);

    // Блоки и обл��сть видимости:
    // '{' и '}' создают блок. Переменные, созданные внутри блока, видимы только
    // внутри него.
    let a = 1;
    {
        let a = 2; // это новое связывание, видимое только внутри блока
        println!("   a внутри блока = {}", a);
    }
    println!("   a снаружи блока = {}", a); // снаружи всё ещё видно внешнее связывание a

    // Конец примера. Комментарии выше подробно объясняют, что делает каждая часть.
    println!(
        "\nДля упражнений запустите day-1/variables_exercises.rs (там есть тесты и более подробные задания)."
    );
}
