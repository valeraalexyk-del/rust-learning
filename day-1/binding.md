# Связывание (Binding) — Ключевая концепция Rust

> **Это самое важное, что нужно понять в первый день изучения Rust.**

---

## Почему "связывание", а не "переменная"?

В большинстве языков программирования мы говорим "объявить переменную":

```python
# Python
x = 5  # "создали переменную x"
```

```javascript
// JavaScript
let x = 5;  // "объявили переменную x"
```

В Rust мы говорим **"создать связывание"** (binding):

```rust
let x = 5;  // создали СВЯЗЫВАНИЕ имени x со значением 5
```

### В чём разница?

**Переменная** (в других языках) — это "коробка с именем", куда можно класть значения:
```
┌─────┐
│  5  │  ← коробка с именем "x"
└─────┘
```

**Связывание** (в Rust) — это **имя, привязанное к значению**:
```
  x ───────► 5
  │          │
имя      значение
```

Это не просто терминология — это **фундаментальное различие**, которое влияет на:
- Как работает память
- Как передаётся владение (ownership)
- Почему Rust безопасен

---

## Анатомия связывания: каждый символ

Разберём строку `let x = 5;` посимвольно:

```
let x = 5;
│   │ │ │ │
│   │ │ │ └─ ; (точка с запятой) — конец инструкции
│   │ │ └─── 5 — значение (литерал)
│   │ └───── = — оператор связывания
│   └─────── x — имя связывания
└─────────── let — ключевое слово "создать связывание"
```

### `let` — ключевое слово

```rust
let x = 5;
^^^
```

- **Что делает:** Говорит компилятору "сейчас будет создано связывание"
- **Почему `let`:** От английского "let" — "пусть", "позволить". Читается как "пусть x будет равно 5"
- **Аналогия:** Как объявление в математике: "Пусть x = 5"

### `x` — имя связывания (идентификатор)

```rust
let x = 5;
    ^
```

- **Что делает:** Даёт имя значению, чтобы обращаться к нему позже
- **Правила именования:**
  - Начинается с буквы или `_`
  - Содержит буквы, цифры, `_`
  - Использует `snake_case` (слова_через_подчёркивание)

```rust
// Правильно:
let count = 10;
let user_name = "Alice";
let _unused = 42;      // подчёркивание: "знаю, что не использую"
let MAX_SIZE = 100;    // для констант: SCREAMING_SNAKE_CASE

// Неправильно:
let 1st = 10;          // нельзя начинать с цифры
let user-name = "Bob"; // нельзя использовать дефис
```

### `=` — оператор связывания

```rust
let x = 5;
      ^
```

- **Что делает:** Связывает имя слева со значением справа
- **Важно:** Это НЕ математическое равенство! Это **действие** — "привязать"
- **Направление:** Справа налево. Сначала вычисляется правая часть, потом результат связывается с именем

```rust
let y = 2 + 3;  // сначала вычисляется 2+3=5, потом y связывается с 5
```

### `5` — значение (литерал)

```rust
let x = 5;
        ^
```

- **Что делает:** Само значение, которое мы хотим сохранить
- **Тип:** Компилятор сам определит тип (`i32` для целых чисел по умолчанию)

### `;` — точка с запятой

```rust
let x = 5;
         ^
```

- **Что делает:** Завершает инструкцию (statement)
- **Почему обязательна:** Rust различает:
  - **Инструкции** (statements) — действия, заканчиваются `;`
  - **Выражения** (expressions) — возвращают значение, БЕЗ `;`

```rust
let x = 5;     // инструкция (с точкой запятой)
x + 1          // выражение (без точки запятой) — возвращает 6
```

---

## Неизменяемость по умолчанию

В Rust связывания **неизменяемы по умолчанию**:

```rust
let x = 5;
x = 6;      // ОШИБКА КОМПИЛЯЦИИ!
```

```
error[E0384]: cannot assign twice to immutable variable `x`
```

### Почему это хорошо?

1. **Безопасность:** Значение не изменится неожиданно
2. **Читаемость:** Видя `let x = 5`, знаешь — x всегда будет 5
3. **Оптимизация:** Компилятор может оптимизировать неизменяемые данные

### Как сделать изменяемым?

Используй `mut` (от "mutable" — изменяемый):

```rust
let mut x = 5;
    ^^^
```

Разбор:

```
let mut x = 5;
│   │   │ │ │
│   │   │ │ └─ значение
│   │   │ └─── оператор связывания
│   │   └───── имя
│   └───────── mut — модификатор "изменяемый"
└───────────── let — создать связывание
```

Теперь можно изменять:

```rust
let mut x = 5;
println!("x = {}", x);  // x = 5

x = 10;                 // теперь можно!
println!("x = {}", x);  // x = 10

x = x + 1;              // и так тоже
println!("x = {}", x);  // x = 11
```

---

## Shadowing (Затенение)

**Shadowing** — создание нового связывания с тем же именем:

```rust
let x = 5;
let x = x + 1;  // НОВОЕ связывание, не изменение старого!
let x = x * 2;
```

### Чем отличается от `mut`?

| Аспект | `mut` | Shadowing |
|--------|-------|-----------|
| Что происходит | Изменение значения | Создание нового связывания |
| Можно менять тип? | Нет | Да |
| Ключевое слово | `let mut x = ...` | `let x = ...` (повторно) |

Пример с изменением типа (только shadowing):

```rust
let spaces = "   ";        // &str (строка)
let spaces = spaces.len(); // usize (число) — ТОТ ЖЕ ИДЕНТИФИКАТОР, ДРУГОЙ ТИП!
```

С `mut` это невозможно:

```rust
let mut spaces = "   ";
spaces = spaces.len();  // ОШИБКА! Нельзя изменить тип
```

### Shadowing в блоках

```rust
let x = 5;

{
    let x = 10;  // новое связывание внутри блока
    println!("внутри: x = {}", x);  // 10
}

println!("снаружи: x = {}", x);  // 5 (внешнее связывание)
```

---

## Аннотация типа

По умолчанию Rust **выводит тип автоматически**:

```rust
let x = 5;      // компилятор определит: i32
let y = 3.14;   // компилятор определит: f64
let z = true;   // компилятор определит: bool
```

Но можно указать тип явно:

```rust
let x: i32 = 5;
      ^^^^
```

Разбор:

```
let x: i32 = 5;
│   │  │   │ │
│   │  │   │ └─ значение
│   │  │   └─── оператор связывания
│   │  └─────── тип (32-битное знаковое целое)
│   └────────── имя
└──────────────let
```

### Когда указывать тип явно?

1. **Когда компилятор не может вывести:**
```rust
let guess: u32 = "42".parse().expect("Не число!");
// без : u32 компилятор не знает, во что парсить
```

2. **Для читаемости:**
```rust
let count: usize = 0;  // явно видно, что это индекс/размер
```

3. **Для конкретного типа:**
```rust
let small: i8 = 127;   // нужен именно i8, а не i32
```

---

## Константы vs Связывания

```rust
const MAX_POINTS: u32 = 100_000;
let score = 50;
```

| Аспект | `const` | `let` |
|--------|---------|-------|
| Изменяемость | Никогда | По умолчанию нет, с `mut` — да |
| Тип | Обязателен | Можно опустить |
| Вычисление | Только compile-time | Runtime тоже |
| Область | Глобальная возможна | Только локальная |
| Именование | `SCREAMING_SNAKE_CASE` | `snake_case` |

```rust
// Константа — вычисляется при компиляции
const SECONDS_IN_HOUR: u32 = 60 * 60;

// Связывание — может вычисляться в runtime
let user_input = read_line();
```

---

## Полный разбор примера

```rust
fn main() {
    const MAX_HEALTH: i32 = 100;

    let player_name = "Hero";
    let mut health = MAX_HEALTH;

    println!("{} has {} HP", player_name, health);

    health = health - 20;
    println!("{} has {} HP", player_name, health);

    let health = "full";  // shadowing: теперь health — строка!
    println!("{}'s health is {}", player_name, health);
}
```

Вывод:
```
Hero has 100 HP
Hero has 80 HP
Hero's health is full
```

Разбор каждой строки:

| Строка | Что происходит |
|--------|----------------|
| `const MAX_HEALTH: i32 = 100;` | Константа, тип обязателен, вычисляется при компиляции |
| `let player_name = "Hero";` | Неизменяемое связывание, тип `&str` выведен |
| `let mut health = MAX_HEALTH;` | Изменяемое связывание, значение копируется из константы |
| `health = health - 20;` | Изменение значения (возможно благодаря `mut`) |
| `let health = "full";` | Shadowing! Новое связывание с тем же именем, другой тип |

---

## Почему это важно для Rust?

Связывание — фундамент системы **владения** (ownership):

```rust
let s1 = String::from("hello");
let s2 = s1;  // s1 ПЕРЕМЕЩАЕТСЯ в s2

println!("{}", s1);  // ОШИБКА! s1 больше не владеет данными
```

В Rust:
- Каждое значение имеет **владельца** (owner)
- Связывание `let s1 = ...` делает `s1` владельцем
- При `let s2 = s1` владение **перемещается** (move)
- Старое связывание `s1` становится недействительным

Это предотвращает:
- Двойное освобождение памяти
- Использование после освобождения
- Гонки данных

**Именно поэтому Rust использует термин "связывание" — это не просто имя для значения, это отношение владения.**

---

## Шпаргалка

```rust
// Неизменяемое связывание
let x = 5;

// Изменяемое связывание
let mut y = 10;
y = 20;  // OK

// С явным типом
let z: f64 = 3.14;

// Shadowing (новое связывание)
let x = x + 1;
let x = "теперь строка";  // можно менять тип

// Константа
const MAX: u32 = 100;
```

---

## Ключевые выводы

1. **`let` создаёт связывание** — привязку имени к значению
2. **Неизменяемость по умолчанию** — безопасность и оптимизация
3. **`mut` делает изменяемым** — явное намерение изменять
4. **Shadowing** — новое связывание с тем же именем (можно менять тип)
5. **Связывание = владение** — основа безопасности памяти в Rust
