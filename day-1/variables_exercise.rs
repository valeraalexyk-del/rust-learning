// Интерактивная версия: задания, подсказки и тесты.
// В комментариях на русском подробно объяснено, что о��начает каждый
// символ/конструкция.

// Короткое пояснение используемых символов (наиболее важные):
// - let — создаёт связывание (имя для значения).
// - mut — делает связывание изменяемым (можно присваивать новое значение).
// - = — оператор присвоения/инициализации (присваивает выражение переменной).
// - ; — завершает инструкцию (statement). Без ';' выражение возвращается из
//   блока.
// - { } — блок: ограничивает область видимости (scope).
// - : тип — явная аннотация типа, например `: f64`.
// - :: — доступ к связанным элементам типа, например `String::from`.
// - . — вызов метода или доступ к полю, например `s.push_str()`.
// - println! — макрос для вывода; "!" означает, что это макрос.
// - "..." — строковый литерал (&str); String::from("...") превращает &str в
//   String.

// Константа с явной аннотацией типа:
const MAX_POINTS: u32 = 100_000; // u32 — беззнаковое 32-битное целое

fn main() {
    // Этот main даёт подсказку, а реальные проверки — в unit-тестах ниже.
    println!("Запустите `cargo test` для проверки заданий.");
}

// ----------------- Задание 1: mutability -----------------
// Требование: сделать связывание изменяемым и вернуть новое значение.
// Объяснение синтаксиса используемого в решении:
// - let mut y = 10;  // let — объявление, mut — изменяемость, '=' —
//   инициализация, ';' — конец инструкции.
// - y = 20;  // присваивание: имя = выражение;
// Возвращаем значение y (последняя инструкция в функции возвращает значение).
pub fn exercise_mutability() -> i32 {
    let mut y = 10; // создаём изменяемую переменную y и присваиваем 10
    y = 20; // меняем значение y на 20
    y // возвращаем текущее значение y (без ';' выражение возвращается)
}

// ----------------- Задание 2: shadowing -----------------
// Показать, что повторный let создаёт новое связывание (shadowing), и можно
// менять тип. Объяснение:
// - let x = 5;       // x: i32
// - let x = x + 1;   // новое связывание x: i32 (берём старое значение,
//   прибавляем 1)
// - let x = "text";  // снова новое связывание x: &str (другой тип)
// Возвращаем финальное значение (тип &str).
pub fn exercise_shadowing() -> &'static str {
    let x = 5; // x — целое число
    let x = x + 1; // создаём новое связывание с тем же именем
    let x = "now string"; // снова создаём новое связывание, теперь это строковый срез (&str)
    x // возвращаем финальную строку
}

// ----------------- Задание 3: явная аннотация типа -----------------
// Объяснение:
// - let z: f64 = 3.14;  // ':' указывает, что переменная z имеет тип f64.
// Возврат z показывает, что тип действительно f64.
pub fn exercise_typed() -> f64 {
    let z: f64 = 3.14;
    z
}

// ----------------- Задание 4: область видимости (scope) -----------------
// Объяснение:
// - let a = 1;  // внешнее связывание
// - { let a = 2; ... }  // внутри блока создаётся новое связывание a, видимое
//   только в блоке
// Мы возвращаем кортеж (внешнее значение, значение из блока), чтобы проверить
// отличие.
pub fn exercise_scope() -> (i32, i32) {
    let a = 1; // внешнее связывание a
    let inner = {
        let a = 2; // локальное связывание a внутри блока
        a // возвращаем значение локального a из блока
    };
    (a, inner) // возвращаем (внешнее, внутреннее)
}

// ----------------- Задание 5: String и поведение при копировании
// ----------------- Объяснение:
// - String::from("hello") создает heap-строку (String).
// - При присваивании без clone владение перемещается: let s2 = s1; — тогда s1
//   становится недоступной.
// - s1.clone() создаёт глубокую копию, тогда оба значения можно использовать
//   независимо.
pub fn exercise_string_behavior() -> (String, String) {
    let s1 = String::from("hello"); // создаём String; данные хранятся в куче
    let mut s2 = s1.clone(); // clone() создаёт независимую копию
    s2.push_str(", world!"); // метод push_str добавляет текст в конец строки s2
    (s1, s2) // возвращаем обе строки, чтобы увидеть разницу
}

// ----------------- Unit-тесты -----------------
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn t_mutability() {
        assert_eq!(exercise_mutability(), 20);
    }

    #[test]
    fn t_shadowing() {
        assert_eq!(exercise_shadowing(), "now string");
    }

    #[test]
    fn t_typed() {
        let v = exercise_typed();
        // Проверяем равенство с малой дельтой — но здесь значение точное.
        assert!((v - 3.14).abs() < std::f64::EPSILON);
    }

    #[test]
    fn t_scope() {
        let (outside, inside) = exercise_scope();
        assert_eq!(outside, 1);
        assert_eq!(inside, 2);
    }

    #[test]
    fn t_string_behavior() {
        let (s1, s2) = exercise_string_behavior();
        assert_eq!(s1, "hello");
        assert_eq!(s2, "hello, world!");
    }
}
