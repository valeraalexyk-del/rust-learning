# Как работает память компьютера

> **Зачем это знать?** Rust даёт контроль над памятью. Чтобы понимать Rust, нужно понимать память.

---

## Что такое память?

**Память (RAM)** — это место, где компьютер хранит данные во время работы программы.

Представь память как **огромный шкаф с пронумерованными ячейками**:

```
Память компьютера (упрощённо)
┌─────────────────────────────────────┐
│ Ячейка 0    │ Ячейка 1   │ Ячейка 2 │ ...
│ [данные]    │ [данные]   │ [данные] │
└─────────────────────────────────────┘
      ↑             ↑            ↑
   адрес 0       адрес 1      адрес 2
```

- **Ячейка** — место для хранения данных (обычно 1 байт = 8 бит)
- **Адрес** — номер ячейки (чтобы найти данные)

---

## Биты и байты — единицы измерения

### Бит (bit)

**Бит** — минимальная единица информации. Может быть только `0` или `1`.

```
Один бит:  0  или  1
           ↑       ↑
         выкл    вкл
```

Аналогия: выключатель света — либо выключен (0), либо включен (1).

### Байт (byte)

**Байт** = 8 бит. Может хранить числа от 0 до 255.

```
Один байт (8 бит):
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 1 │ 0 │ 0 │ 1 │ 0 │ 1 │  = 101 в десятичной системе
└───┴───┴───┴───┴───┴───┴───┴───┘
```

### Размеры данных

| Название | Размер | Пример |
|----------|--------|--------|
| 1 бит | 0 или 1 | Да/Нет |
| 1 байт | 8 бит | Число 0-255, один символ ASCII |
| 1 килобайт (KB) | 1024 байт | Короткий текст |
| 1 мегабайт (MB) | 1024 KB | Фотография |
| 1 гигабайт (GB) | 1024 MB | Фильм |

---

## Две области памяти: Стек и Куча

Программа использует два типа памяти:

```
┌─────────────────────────────────────────────────────────┐
│                    ПАМЯТЬ ПРОГРАММЫ                      │
├─────────────────────────┬───────────────────────────────┤
│         СТЕК            │            КУЧА               │
│        (Stack)          │           (Heap)              │
│                         │                               │
│  Быстрый, маленький     │  Медленнее, большой           │
│  Автоматический         │  Ручное управление            │
│  Фиксированный размер   │  Динамический размер          │
│                         │                               │
│  Локальные переменные   │  Строки, массивы,             │
│  Числа, bool            │  большие структуры            │
└─────────────────────────┴───────────────────────────────┘
```

---

## Стек (Stack)

### Что это?

**Стек** — область памяти, работающая по принципу **"последний вошёл — первый вышел"** (LIFO).

Представь стопку тарелок:
- Кладёшь тарелку **сверху**
- Берёшь тарелку тоже **сверху**
- Нельзя вытащить тарелку из середины

```
Стек (Stack)
─────────────
     ↓ кладём сюда
┌─────────┐
│ данные  │ ← верх стека (последнее добавленное)
├─────────┤
│ данные  │
├─────────┤
│ данные  │
├─────────┤
│ данные  │ ← низ стека (первое добавленное)
└─────────┘
```

### Как работает?

При вызове функции создаётся **кадр стека** (stack frame):

```rust
fn main() {
    let a = 5;       // a кладётся в стек
    let b = 10;      // b кладётся в стек
    let c = add(a, b);  // вызов функции
}

fn add(x: i32, y: i32) -> i32 {
    let result = x + y;  // result в стеке функции add
    result
}
```

```
Стек во время выполнения:

1. Начало main()        2. Вызов add()         3. После return
┌─────────────┐        ┌─────────────┐        ┌─────────────┐
│             │        │ result: 15  │ ←add   │             │
│             │        ├─────────────┤        │             │
│             │        │ y: 10       │        │             │
│             │        ├─────────────┤        │             │
│             │        │ x: 5        │        │             │
├─────────────┤        ├─────────────┤        ├─────────────┤
│ b: 10       │ ←main  │ b: 10       │ ←main  │ c: 15       │ ←main
├─────────────┤        ├─────────────┤        ├─────────────┤
│ a: 5        │        │ a: 5        │        │ b: 10       │
└─────────────┘        └─────────────┘        ├─────────────┤
                                              │ a: 5        │
                                              └─────────────┘
```

### Преимущества стека

| Плюс | Почему |
|------|--------|
| **Очень быстрый** | Просто двигаем указатель вверх/вниз |
| **Автоматический** | Память освобождается сама при выходе из функции |
| **Предсказуемый** | Размер известен заранее |

### Ограничения стека

| Минус | Почему |
|-------|--------|
| **Маленький размер** | Обычно 1-8 MB |
| **Фиксированный размер данных** | Размер должен быть известен при компиляции |

---

## Куча (Heap)

### Что это?

**Куча** — большая область памяти для данных переменного размера.

```
Куча (Heap)
───────────────────────────────────────────
┌─────┬─────────────┬───┬─────────┬───────┐
│ ### │ Hello World │   │ [1,2,3] │ ##### │
└─────┴─────────────┴───┴─────────┴───────┘
   ↑         ↑        ↑       ↑        ↑
 занято   строка   свободно  массив  занято
```

- Данные разбросаны по куче
- Есть свободные и занятые участки
- Нужен **указатель** чтобы найти данные

### Как работает?

1. Программа просит: "Дай мне место для строки длиной 11 символов"
2. Система ищет свободный участок нужного размера
3. Возвращает **адрес** (указатель) этого участка
4. Данные записываются по этому адресу

```rust
let s = String::from("Hello World");
```

```
Что происходит:

СТЕК                          КУЧА
┌──────────────┐              ┌─────────────┐
│ s:           │              │             │
│  ptr ────────┼──────────────►│Hello World │
│  len: 11     │              │             │
│  capacity:11 │              └─────────────┘
└──────────────┘
     ↑
  метаданные                     ↑
  на стеке                   сами данные
                             в куче
```

### Преимущества кучи

| Плюс | Почему |
|------|--------|
| **Большой размер** | Гигабайты памяти |
| **Динамический** | Размер можно менять во время работы |
| **Гибкость** | Данные живут сколько нужно |

### Недостатки кучи

| Минус | Почему |
|-------|--------|
| **Медленнее** | Нужно искать свободное место |
| **Ручное управление** | Нужно освобождать память |
| **Фрагментация** | Память может "дырявиться" |

---

## Сравнение: Стек vs Куча

```
┌─────────────────────┬─────────────────────┐
│       СТЕК          │        КУЧА         │
├─────────────────────┼─────────────────────┤
│                     │                     │
│   Быстрый           │   Медленный         │
│   ●●●●●             │   ●●○○○             │
│                     │                     │
│   Маленький         │   Большой           │
│   ~1-8 MB           │   ~гигабайты        │
│                     │                     │
│   Автоматический    │   Ручной            │
│   (сам очищается)   │   (надо удалять)    │
│                     │                     │
│   Фиксированный     │   Динамический      │
│   размер            │   размер            │
│                     │                     │
├─────────────────────┼─────────────────────┤
│ Что хранить:        │ Что хранить:        │
│ • числа (i32, f64)  │ • строки (String)   │
│ • bool              │ • векторы (Vec)     │
│ • char              │ • большие структуры │
│ • маленькие данные  │ • данные неизвест-  │
│   известного размера│   ного размера      │
└─────────────────────┴─────────────────────┘
```

---

## Типы в Rust: где хранятся?

### На стеке (Copy-типы)

```rust
let x: i32 = 42;      // 4 байта на стеке
let y: f64 = 3.14;    // 8 байт на стеке
let z: bool = true;   // 1 байт на стеке
let c: char = 'A';    // 4 байта на стеке
```

Эти типы:
- Имеют известный фиксированный размер
- Копируются при присваивании
- Автоматически удаляются

### В куче (не Copy-типы)

```rust
let s: String = String::from("привет");  // данные в куче
let v: Vec<i32> = vec![1, 2, 3];         // данные в куче
```

Эти типы:
- Размер может меняться
- **Перемещаются** (move) при присваивании
- Требуют явного управления (в Rust — автоматического через ownership)

---

## Проблемы с памятью (в других языках)

### 1. Утечка памяти (Memory Leak)

Память выделена, но не освобождена:

```
Программа работает...
┌────────────────────────────────────────┐
│ [занято] [занято] [занято] [занято]    │  ← всё занято!
│ некому освободить — память кончилась   │
└────────────────────────────────────────┘
```

### 2. Использование после освобождения (Use After Free)

```
1. Создали данные       2. Освободили        3. Используем???
┌─────────┐            ┌─────────┐          ┌─────────┐
│ "Hello" │     →      │ мусор   │    →     │ мусор   │ ← ОПАСНО!
└─────────┘            └─────────┘          └─────────┘
     ↑                                           ↑
  ptr указывает                          ptr всё ещё указывает
                                         но данных уже нет!
```

### 3. Двойное освобождение (Double Free)

```rust
// Псевдокод (так делать НЕЛЬЗЯ)
let ptr = allocate("Hello");
free(ptr);   // освободили
free(ptr);   // освободили ещё раз — КРАШ!
```

---

## Как Rust решает эти проблемы?

### Система владения (Ownership)

```
┌─────────────────────────────────────────────────────────┐
│                     ПРАВИЛА RUST                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. У каждого значения есть ВЛАДЕЛЕЦ                    │
│                                                         │
│  2. Владелец может быть только ОДИН                     │
│                                                         │
│  3. Когда владелец выходит из области видимости —       │
│     память автоматически освобождается                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

Пример:

```rust
fn main() {
    let s = String::from("hello");  // s — владелец строки

    // здесь s используется
    println!("{}", s);

}  // ← s выходит из области видимости
   //   память АВТОМАТИЧЕСКИ освобождается
   //   никаких утечек!
```

### Перемещение (Move)

```rust
let s1 = String::from("hello");
let s2 = s1;  // s1 ПЕРЕМЕЩАЕТСЯ в s2

// s1 больше нельзя использовать!
// println!("{}", s1);  // ОШИБКА КОМПИЛЯЦИИ
```

```
ДО перемещения:                ПОСЛЕ перемещения:

СТЕК          КУЧА            СТЕК          КУЧА
┌────┐      ┌───────┐         ┌────┐      ┌───────┐
│ s1 │─────►│ hello │         │ s1 │ ✗    │ hello │
└────┘      └───────┘         └────┘      └───────┘
                                              ↑
                              ┌────┐          │
                              │ s2 │──────────┘
                              └────┘

s1 недействителен!            s2 — новый владелец
```

### Заимствование (Borrowing)

Можно "одолжить" данные без передачи владения:

```rust
let s = String::from("hello");
let len = calculate_length(&s);  // одалживаем s
println!("Длина '{}' = {}", s, len);  // s всё ещё доступен!

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

```
&s — это ссылка (reference):

СТЕК              СТЕК              КУЧА
┌─────┐          ┌─────┐          ┌───────┐
│  s  │──────────┼──────────────► │ hello │
└─────┘          └─────┘          └───────┘
                    ↑
                 ┌─────┐
                 │ &s  │ ← ссылка (не владеет, только смотрит)
                 └─────┘
```

---

## Итог: почему это важно?

| Проблема | C/C++ | Java/Python | Rust |
|----------|-------|-------------|------|
| Утечки памяти | Возможны | GC спасает | Невозможны |
| Use after free | Возможны | GC спасает | Невозможны |
| Double free | Возможны | GC спасает | Невозможны |
| Скорость | Быстро | Медленно (GC) | Быстро |
| Контроль | Полный | Нет | Полный |

**Rust даёт:**
- Скорость как у C/C++
- Безопасность как у Java/Python (даже лучше!)
- Без сборщика мусора (GC)

---

## Шпаргалка

```
ПАМЯТЬ = СТЕК + КУЧА

СТЕК:                          КУЧА:
• Быстрый                      • Медленный
• Маленький (~1-8 MB)          • Большой (гигабайты)
• Автоматический               • Требует управления
• Фиксированный размер         • Динамический размер
• i32, f64, bool, char         • String, Vec, Box

RUST ГАРАНТИРУЕТ:
• Нет утечек памяти
• Нет use-after-free
• Нет double-free
• Без GC (быстро!)

КАК? → Система владения (Ownership)
1. Один владелец
2. Move при присваивании
3. Автоматическое освобождение
```
