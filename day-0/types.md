# Типы данных — Фундамент программирования

> **Зачем это знать?** Rust — строго типизированный язык. Каждое значение имеет тип, и компилятор проверяет типы ДО запуска программы.

---

## Что такое тип данных?

**Тип данных** определяет:
1. **Сколько памяти** занимает значение
2. **Как интерпретировать** биты в памяти
3. **Какие операции** можно выполнять

```
Число 65 в памяти:
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 0 │ 0 │ 0 │ 0 │ 0 │ 1 │  = 01000001 (двоичное)
└───┴───┴───┴───┴───┴───┴───┴───┘

Как тип i8 (число):     65
Как тип char (символ):  'A'
Как тип bool:           ???  (некорректно!)

Одни и те же биты — разное значение в зависимости от типа!
```

---

## Скалярные типы (простые)

Скалярные типы хранят **одно значение**.

### 1. Целые числа (Integers)

Целые числа — без дробной части: `-5`, `0`, `42`, `1000`

#### Знаковые (signed) — могут быть отрицательными

| Тип | Размер | Диапазон | Пример |
|-----|--------|----------|--------|
| `i8` | 1 байт | -128 ... 127 | `let x: i8 = -50;` |
| `i16` | 2 байта | -32768 ... 32767 | `let x: i16 = 1000;` |
| `i32` | 4 байта | ≈ -2 млрд ... +2 млрд | `let x: i32 = 42;` |
| `i64` | 8 байт | очень большой | `let x: i64 = 9999999999;` |
| `i128` | 16 байт | астрономический | `let x: i128 = ...;` |
| `isize` | 4 или 8 байт | зависит от архитектуры | указатели, индексы |

#### Беззнаковые (unsigned) — только положительные

| Тип | Размер | Диапазон | Пример |
|-----|--------|----------|--------|
| `u8` | 1 байт | 0 ... 255 | `let x: u8 = 200;` |
| `u16` | 2 байта | 0 ... 65535 | `let x: u16 = 60000;` |
| `u32` | 4 байта | 0 ... ≈4 млрд | `let x: u32 = 42;` |
| `u64` | 8 байт | очень большой | `let x: u64 = ...;` |
| `u128` | 16 байт | астрономический | `let x: u128 = ...;` |
| `usize` | 4 или 8 байт | зависит от архитектуры | размеры, индексы |

#### Почему разные размеры?

```
Память — ресурс. Используй столько, сколько нужно.

Возраст человека (0-150):  u8  достаточно (1 байт)
Население города:          u32 нужно     (4 байта)
ID в базе данных:          u64 или больше (8 байт)
```

#### Визуализация размеров

```
i8  (1 байт):   [████████]

i16 (2 байта):  [████████][████████]

i32 (4 байта):  [████████][████████][████████][████████]

i64 (8 байт):   [████████][████████][████████][████████]
                [████████][████████][████████][████████]
```

#### По умолчанию: `i32`

```rust
let x = 42;  // компилятор выберет i32
```

Почему `i32`? Оптимальный баланс между размером и скоростью на современных процессорах.

---

### 2. Числа с плавающей точкой (Floats)

Дробные числа: `3.14`, `-0.001`, `2.0`

| Тип | Размер | Точность | Пример |
|-----|--------|----------|--------|
| `f32` | 4 байта | ~6-7 знаков | `let x: f32 = 3.14;` |
| `f64` | 8 байт | ~15-16 знаков | `let x: f64 = 3.14159265359;` |

#### По умолчанию: `f64`

```rust
let pi = 3.14;  // компилятор выберет f64
```

#### Почему `f64`?

На современных процессорах `f64` такой же быстрый как `f32`, но точнее.

#### Осторожно с дробными числами!

```rust
let x = 0.1 + 0.2;
println!("{}", x);  // 0.30000000000000004  (не 0.3!)
```

Это не баг Rust — так работают дробные числа во ВСЕХ языках. Причина — особенности представления в двоичной системе.

---

### 3. Логический тип (Boolean)

Только два значения: `true` или `false`

```rust
let is_active: bool = true;
let is_deleted: bool = false;
```

| Тип | Размер | Значения |
|-----|--------|----------|
| `bool` | 1 байт | `true`, `false` |

#### Почему 1 байт, а не 1 бит?

Процессоры работают минимум с байтами. Один бит нельзя адресовать напрямую.

#### Использование

```rust
let is_adult = age >= 18;        // сравнение → bool
let can_vote = is_adult && is_citizen;  // логическое И

if is_active {
    // выполнится если true
}
```

---

### 4. Символ (Character)

Один символ Unicode.

```rust
let letter: char = 'A';
let emoji: char = '😀';
let chinese: char = '中';
```

| Тип | Размер | Диапазон |
|-----|--------|----------|
| `char` | 4 байта | Любой символ Unicode |

#### Важно: одинарные кавычки!

```rust
let c: char = 'A';      // char — одинарные кавычки
let s: &str = "A";      // строка — двойные кавычки
```

#### Почему 4 байта?

Unicode содержит более 140 000 символов (все языки мира, эмодзи, математические символы). 4 байта гарантируют, что ЛЮБОЙ символ поместится.

---

## Составные типы (Compound)

Составные типы группируют несколько значений.

### 1. Кортеж (Tuple)

Фиксированная коллекция значений **разных типов**.

```rust
let person: (i32, f64, char) = (25, 175.5, 'M');
//           ↑    ↑     ↑
//         возраст рост  пол
```

#### Доступ к элементам

```rust
let person = (25, 175.5, 'M');

// Через индекс (начинается с 0)
let age = person.0;     // 25
let height = person.1;  // 175.5
let gender = person.2;  // 'M'

// Через деструктуризацию
let (age, height, gender) = person;
```

#### Визуализация

```
Кортеж (25, 175.5, 'M'):
┌─────────┬──────────┬─────────┐
│ i32: 25 │ f64:175.5│ char:'M'│
└─────────┴──────────┴─────────┘
  .0         .1         .2
```

#### Unit-тип `()`

Пустой кортеж — специальный тип "ничего":

```rust
let nothing: () = ();
```

Функции без return возвращают `()`.

---

### 2. Массив (Array)

Фиксированная коллекция значений **одного типа**.

```rust
let numbers: [i32; 5] = [1, 2, 3, 4, 5];
//            ↑    ↑
//          тип  длина
```

#### Доступ к элементам

```rust
let numbers = [10, 20, 30, 40, 50];

let first = numbers[0];   // 10
let third = numbers[2];   // 30
let last = numbers[4];    // 50

// numbers[5] — ОШИБКА! Выход за границы
```

#### Визуализация

```
Массив [10, 20, 30, 40, 50]:
┌──────┬──────┬──────┬──────┬──────┐
│  10  │  20  │  30  │  40  │  50  │
└──────┴──────┴──────┴──────┴──────┘
 [0]    [1]    [2]    [3]    [4]
```

#### Создание массива с одинаковыми значениями

```rust
let zeros = [0; 5];  // [0, 0, 0, 0, 0]
//           ↑  ↑
//      значение  длина
```

#### Массив vs Кортеж

| Аспект | Массив `[T; N]` | Кортеж `(T1, T2, ...)` |
|--------|-----------------|------------------------|
| Типы элементов | Одинаковые | Разные |
| Доступ | `arr[0]` | `tup.0` |
| Длина | Фиксированная | Фиксированная |

---

## Строки — особый случай

В Rust есть ДВА типа строк:

### `&str` — строковый срез (slice)

```rust
let s: &str = "Hello";  // хранится в бинарнике программы
```

- Неизменяемый
- Фиксированного размера
- Быстрый (нет выделения памяти)

### `String` — динамическая строка

```rust
let s: String = String::from("Hello");  // хранится в куче
```

- Изменяемый (можно добавлять текст)
- Размер может меняться
- Владеет своими данными

```
&str "Hello":                    String::from("Hello"):

Только указатель                 СТЕК           КУЧА
┌────────────┐                  ┌──────┐      ┌───────┐
│ ptr → ... │                   │ ptr ─┼─────►│ Hello │
│ len: 5    │                   │ len:5│      └───────┘
└────────────┘                  │cap:5 │
                                └──────┘
```

Подробнее о строках — в следующих днях!

---

## Вывод типа (Type Inference)

Rust **автоматически определяет** типы:

```rust
let x = 5;        // i32 (по умолчанию для целых)
let y = 3.14;     // f64 (по умолчанию для дробных)
let z = true;     // bool
let c = 'A';      // char
let s = "hello";  // &str
```

Но иногда нужно указать явно:

```rust
// Компилятор не может определить тип — неоднозначность
let guess = "42".parse().expect("Не число!");  // ОШИБКА!

// Указываем явно
let guess: u32 = "42".parse().expect("Не число!");  // OK
```

---

## Преобразование типов (Casting)

В Rust НЕТ автоматического преобразования типов:

```rust
let x: i32 = 5;
let y: i64 = x;  // ОШИБКА! Разные типы
```

Нужно преобразовывать явно с помощью `as`:

```rust
let x: i32 = 5;
let y: i64 = x as i64;  // OK

let a: f64 = 3.99;
let b: i32 = a as i32;  // 3 (отбрасывает дробную часть)
```

**Почему так?** Безопасность. Явное преобразование показывает, что программист понимает, что делает.

---

## Переполнение (Overflow)

Что происходит, когда число не помещается в тип?

```rust
let x: u8 = 255;  // максимум для u8
let y: u8 = x + 1;  // ???
```

| Режим | Что происходит |
|-------|----------------|
| Debug (отладка) | Паника! Программа падает |
| Release (релиз) | Переполнение: 255 + 1 = 0 |

```
Переполнение u8:

255 = 11111111
  +1
────────────────
256 = 100000000  ← 9 бит! Но u8 только 8 бит
        ↓
    = 00000000  = 0 (старший бит отбрасывается)
```

**Rust предупреждает о переполнении в debug-режиме!**

---

## Шпаргалка по типам

```
СКАЛЯРНЫЕ (одно значение):
─────────────────────────────────────────────────
Целые числа:
  Знаковые:    i8, i16, i32, i64, i128, isize
  Беззнаковые: u8, u16, u32, u64, u128, usize
  По умолчанию: i32

Дробные:
  f32, f64
  По умолчанию: f64

Логический:
  bool (true / false)

Символ:
  char ('A', '中', '😀')

СОСТАВНЫЕ (несколько значений):
─────────────────────────────────────────────────
Кортеж:  (T1, T2, T3)    — разные типы, .0 .1 .2
Массив:  [T; N]          — одинаковые типы, [0] [1] [2]

СТРОКИ:
─────────────────────────────────────────────────
&str    — неизменяемый срез, в бинарнике
String  — изменяемый, в куче

ПРЕОБРАЗОВАНИЕ:
─────────────────────────────────────────────────
Явное: value as Type
Нет автоматического преобразования!
```

---

## Почему типы важны в Rust?

1. **Безопасность памяти** — компилятор знает размер каждого значения
2. **Производительность** — нет overhead от динамической типизации
3. **Документация** — типы описывают, что делает код
4. **Ошибки при компиляции** — не при запуске

```rust
// Python (ошибка при запуске):
x = "5"
y = x + 1  # TypeError: can only concatenate str to str

// Rust (ошибка при компиляции):
let x = "5";
let y = x + 1;  // error: cannot add `{integer}` to `&str`
                // Программа даже не запустится!
```

**Rust ловит ошибки ДО того, как программа попадёт к пользователю.**
